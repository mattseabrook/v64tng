#version 450
// Vulkan Compute Shader for GPU-Accelerated Raycasting
// Implements DDA algorithm entirely on GPU for maximum parallelism

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Tile map: storage buffer with uint8 wall types
layout(std430, binding = 0) readonly buffer TileMap {
    uint data[];  // Packed bytes (4 tiles per uint)
};

// Output: BGRA8 image
layout(binding = 1, rgba8) uniform writeonly image2D outputImage;

// Megatexture edge data: pairs [offset,width] as linear array
layout(std430, binding = 2) readonly buffer EdgeData {
    uint data2[];
};

// Per-frame constants
layout(push_constant) uniform RaycastConstants {
    float playerX;
    float playerY;
    float playerAngle;
    float playerFOV;
    uint screenWidth;
    uint screenHeight;
    uint mapWidth;
    uint mapHeight;
    float visualScale;       // Distance shrink factor (typically 3.0)
    float torchRange;        // Light falloff range
    float falloffMul;        // Radial falloff multiplier
    float fovMul;            // FOV adjustment multiplier
    uint supersample;        // Supersampling count
    float wallHeightUnits;   // Wall height in world units relative to width
} pc;

//==============================================================================
// Tile Map Access
//==============================================================================

uint getTile(ivec2 mapPos)
{
    // Bounds check
    if (mapPos.x < 0 || mapPos.y < 0 || 
        mapPos.x >= int(pc.mapWidth) || mapPos.y >= int(pc.mapHeight))
        return 0xFF;  // Out of bounds = solid wall
    
    // Calculate byte index in map
    uint byteIndex = uint(mapPos.y) * pc.mapWidth + uint(mapPos.x);
    
    // Load packed uint (4 bytes per word)
    uint wordIndex = byteIndex >> 2;
    uint byteOffset = byteIndex & 3u;
    uint packedWord = data[wordIndex];
    
    // Extract byte
    uint shift = byteOffset * 8u;
    return (packedWord >> shift) & 0xFFu;
}

//==============================================================================
// DDA Raycasting
//==============================================================================

struct RayHit
{
    float distance;
    int side;  // 0 = vertical wall, 1 = horizontal wall
    bool hitWall;  // true if hit actual wall, false if just reached far distance
    ivec2 cell;       // map cell at hit
    int cardinalSide; // 0=N,1=E,2=S,3=W
    float wallX;      // [0..1] along wall
};

RayHit castRay(vec2 pos, vec2 rayDir)
{
    // DDA initialization
    ivec2 mapPos = ivec2(floor(pos));
    vec2 deltaDist = abs(1.0 / rayDir);
    ivec2 step;
    vec2 sideDist;
    
    // Calculate step direction and initial side distances
    if (rayDir.x < 0.0)
    {
        step.x = -1;
        sideDist.x = (pos.x - float(mapPos.x)) * deltaDist.x;
    }
    else
    {
        step.x = 1;
        sideDist.x = (float(mapPos.x) + 1.0 - pos.x) * deltaDist.x;
    }
    
    if (rayDir.y < 0.0)
    {
        step.y = -1;
        sideDist.y = (pos.y - float(mapPos.y)) * deltaDist.y;
    }
    else
    {
        step.y = 1;
        sideDist.y = (float(mapPos.y) + 1.0 - pos.y) * deltaDist.y;
    }
    
    // DDA loop - bounded to prevent infinite loops
    int side = 0;
    const int MAX_STEPS = 64;
    
    for (int i = 0; i < MAX_STEPS; i++)
    {
        // Step to next grid cell
        if (sideDist.x < sideDist.y)
        {
            sideDist.x += deltaDist.x;
            mapPos.x += step.x;
            side = 0;
        }
        else
        {
            sideDist.y += deltaDist.y;
            mapPos.y += step.y;
            side = 1;
        }
        
        // Sample tile
        uint tile = getTile(mapPos);
        
        // Out of bounds - return distance traveled, no wall hit
        if (tile == 0xFF)
        {
            float dist = side == 0 ? (sideDist.x - deltaDist.x) : (sideDist.y - deltaDist.y);
            RayHit r; r.distance = dist; r.side = side; r.hitWall = false; r.cell = mapPos; r.cardinalSide = 0; r.wallX = 0.0; return r;
        }
        
        // Check for walls (0x01-0xEF, excluding player markers 0xF0-0xF3)
        if (tile >= 1u && (tile < 0xF0u || tile > 0xF3u))
        {
            // Hit wall - calculate distance
            float dist = side == 0 ? (sideDist.x - deltaDist.x) : (sideDist.y - deltaDist.y);
            RayHit r; r.distance = dist; r.side = side; r.hitWall = true; r.cell = mapPos;
            float wx = (side == 0) ? (pos.y + dist * rayDir.y) : (pos.x + dist * rayDir.x);
            wx -= floor(wx);
            r.wallX = wx;
            int cardinal;
            if (side == 0) { cardinal = (step.x > 0) ? 3 : 1; } else { cardinal = (step.y > 0) ? 0 : 2; }
            r.cardinalSide = cardinal;
            return r;
        }
    }
    
    // Max steps reached - return distance traveled, no wall hit
    float dist = side == 0 ? (sideDist.x - deltaDist.x) : (sideDist.y - deltaDist.y);
    RayHit r; r.distance = dist; r.side = side; r.hitWall = false; r.cell = mapPos; r.cardinalSide = 0; r.wallX = 0.0; return r;
}

//==============================================================================
// Shading & Lighting
//==============================================================================

// Procedural mortar mask (approximation to CPU)
float mortarMask(float globalU, float v)
{
    // 1024 px width = 3 world units; vertical: 1 unit per full height
    float x = (globalU / 1024.0) * 3.0;
    float y = v;
    float density = 2.0; // cells/unit
    float X = x * density;
    float Y = y * density;
    int xi = int(floor(X));
    int yi = int(floor(Y));
    float f1 = 1e9, f2 = 1e9;
    for (int dy=-1; dy<=1; ++dy)
    for (int dx=-1; dx<=1; ++dx)
    {
        int cx = xi+dx, cy = yi+dy;
        uint h = uint(cx)*73856093u ^ uint(cy)*19349663u ^ 12345u;
        float jx = fract(float(h) * 0.000000119);
        float jy = fract(float(h) * 0.000000167);
        float fx = float(cx) + jx;
        float fy = float(cy) + jy;
        float dxp = X - fx;
        float dyp = Y - fy;
        float d2 = dxp*dxp + dyp*dyp;
        if (d2 < f1) { f2 = f1; f1 = d2; }
        else if (d2 < f2) { f2 = d2; }
    }
    f1 = sqrt(f1); f2 = sqrt(f2);
    float ridge = (f2 - f1);
    float target = 0.005; // world units
    float m = clamp(1.0 - smoothstep(target*0.25, target*0.75, ridge), 0.0, 1.0);
    return pow(m, 0.8);
}

vec3 shadePixel(uvec2 pixel, RayHit hit, float halfW, float halfH, float maxRadius)
{
    // Pixel Y position (center of pixel)
    float yf = float(pixel.y) + 0.5;
    
    // Radial screen-space vignette
    float dx = float(pixel.x) - halfW;
    float dy = yf - halfH;
    float screenDist = sqrt(dx * dx + dy * dy);
    float screenFactor = max(0.0, 1.0 - (screenDist / maxRadius) * pc.falloffMul);
    
    // Ceiling gradient
    float ceilingShade = (120.0/255.0) * (1.0 - yf / halfH);
    ceilingShade = clamp(ceilingShade, 0.0, 1.0);
    vec3 ceilingColor = vec3(ceilingShade);
    
    // Floor gradient
    float floorRatio = (yf - halfH) / halfH;
    floorRatio = clamp(floorRatio, 0.0, 1.0);
    vec3 floorColor = vec3(90.0/255.0 * floorRatio, 
                           70.0/255.0 * floorRatio, 
                           50.0/255.0 * floorRatio);
    
    // If no wall hit, just render floor/ceiling
    vec3 color;
    if (!hit.hitWall)
    {
        color = (yf < halfH) ? ceilingColor : floorColor;
    }
    else
    {
        // Hit a wall - calculate wall rendering
        float perpWallDist = max(hit.distance / pc.visualScale, 0.01);
        float lineHeight = float(pc.screenHeight) / perpWallDist;
        float drawStart = halfH - lineHeight / 2.0;
        float drawEnd = halfH + lineHeight / 2.0;
        
        // Wall color based on side (darker for horizontal walls)
        vec3 wallColor = hit.side == 1 ? vec3(64.0/255.0) : vec3(120.0/255.0);
        
        // Lighting: torch falloff
        float lightFactor = max(0.0, 1.0 - hit.distance / pc.torchRange);
        vec3 litWall = wallColor * lightFactor;
        
        // Determine pixel color: ceiling, wall, or floor
        if (yf < drawStart)
        {
            // Ceiling
            color = ceilingColor;
        }
        else if (yf > drawEnd)
        {
            // Floor
            color = floorColor;
        }
        else
        {
            // Wall with edge blending for anti-aliasing
            if (yf < drawStart + 1.0)
            {
                // Blend ceiling → wall
                float weight = (yf - drawStart);
                weight = clamp(weight, 0.0, 1.0);
                color = mix(ceilingColor, litWall, weight);
            }
            else if (yf > drawEnd - 1.0)
            {
                // Blend wall → floor
                float weight = (drawEnd - yf);
                weight = clamp(weight, 0.0, 1.0);
                color = mix(floorColor, litWall, weight);
            }
            else
            {
                // Pure wall: overlay procedural mortar using global edge offset
                float v = clamp((yf - drawStart) / max(1.0, (drawEnd - drawStart)), 0.0, 1.0);
        uint idx = (uint(hit.cell.y) * pc.mapWidth + uint(hit.cell.x)) * 4u + uint(hit.cardinalSide & 3);
        uint idx2 = idx * 2u;
    uint xOff = (idx2 + 1u < data2.length()) ? data2[idx2 + 0u] : 0u;
    uint wpx  = (idx2 + 1u < data2.length()) ? data2[idx2 + 1u] : 1024u;
        float globalU = float(xOff) + hit.wallX * float(wpx);
                float a = mortarMask(globalU, v);
                vec3 mortar = vec3(0.30);
                color = mix(litWall, mortar * lightFactor, a);
            }
        }
    }
    
    // Apply screen vignette
    color *= screenFactor;
    
    return color;
}

//==============================================================================
// Main Compute Shader
//==============================================================================

void main()
{
    uvec2 pixel = gl_GlobalInvocationID.xy;
    
    // Bounds check
    if (pixel.x >= pc.screenWidth || pixel.y >= pc.screenHeight)
        return;
    
    // Precompute common values
    float halfW = float(pc.screenWidth) * 0.5;
    float halfH = float(pc.screenHeight) * 0.5;
    float maxRadius = sqrt(halfW * halfW + halfH * halfH);
    
    // Accumulate color for supersampling
    vec3 accumColor = vec3(0.0);
    
    for (uint sampleIdx = 0u; sampleIdx < pc.supersample; sampleIdx++)
    {
        // Camera X coordinate with sub-pixel offset for supersampling
        float camX = 2.0 * (float(pixel.x) + (float(sampleIdx) + 0.5) / float(pc.supersample)) / float(pc.screenWidth) - 1.0;
        
        // Calculate ray angle and direction
        float rayAngle = pc.playerAngle + camX * (pc.playerFOV * 0.5 * pc.fovMul);
        vec2 rayDir = vec2(cos(rayAngle), sin(rayAngle));
        
        // Cast ray
        RayHit hit = castRay(vec2(pc.playerX, pc.playerY), rayDir);
        
        // Shade pixel
        vec3 color = shadePixel(pixel, hit, halfW, halfH, maxRadius);
        accumColor += color;
    }
    
    // Average samples
    accumColor /= float(pc.supersample);
    
    // Write output as RGBA (Vulkan will handle BGRA swizzle)
    imageStore(outputImage, ivec2(pixel), vec4(accumColor, 1.0));
}
